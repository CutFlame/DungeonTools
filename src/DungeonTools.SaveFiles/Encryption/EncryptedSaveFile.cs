using System.IO;
using System.Linq;
using System.Text;
using DungeonTools.Encryption;

namespace DungeonTools.SaveFiles.Encryption {
    public static class EncryptedSaveFile {
        private static readonly byte[] Magic = {0x44, 0x30, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00};
        private static readonly IEncryptionService EncryptionService = new AesEncryptionService();

        public static FileSupportStatus GetSupportStatus(Stream input) {
            if(input.Length <= Magic.Length) {
                return FileSupportStatus.Unsupported;
            }

            long origPos = input.Position;
            input.Seek(0, SeekOrigin.Begin);

            byte[] magic = new byte[Magic.Length];
            input.Read(magic);

            if(magic.SequenceEqual(Magic)) {
                input.Seek(origPos, SeekOrigin.Begin);
                return FileSupportStatus.Encrypted;
            }

            // Read until a valid Json "begin object" token (a literal "{") is found)
            input.Seek(0, SeekOrigin.Begin);
            FileSupportStatus status = FileSupportStatus.Unsupported;
            using BinaryReader reader = new BinaryReader(input, Encoding.UTF8, true);
            while(reader.BaseStream.Position < reader.BaseStream.Length) {
                char ch = reader.ReadChar();

                if(char.IsWhiteSpace(ch)) {
                    continue;
                }

                if(ch == '{') {
                    status = FileSupportStatus.Unencrypted;
                }

                break;
            }

            input.Seek(origPos, SeekOrigin.Begin);
            return status;
        }

        public static Stream Encrypt(Stream input) {
            MemoryStream output = new MemoryStream();
            output.Write(Magic);

            using(Stream encrypted = EncryptionService.Encrypt(input)) {
                encrypted.CopyTo(output);
            }

            output.Seek(0, SeekOrigin.Begin);
            return output;
        }

        public static Stream Decrypt(Stream input) {
            MemoryStream output = new MemoryStream();

            input.Seek(Magic.Length, SeekOrigin.Current);
            using(Stream decrypted = EncryptionService.Decrypt(input)) {
                decrypted.CopyTo(output);
            }

            // Save files generated by the game are padded at the end with some amount of 0x00 which crashes the parser
            long firstNullPos;
            using(BinaryReader reader = new BinaryReader(output)) {
                // ReSharper disable once EmptyEmbeddedStatement
                while(reader.BaseStream.Position < reader.BaseStream.Length && reader.ReadByte() != 0) ;
                firstNullPos = reader.BaseStream.Position;
            }
            
            output.SetLength(firstNullPos);
            output.Seek(0, SeekOrigin.Begin);
            return output;
        }
    }
}
